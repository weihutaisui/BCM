#!/usr/bin/perl

use strict;
use warnings;
use Getopt::Long;
use Data::Dumper;
use FindBin qw($Bin);

my $aflag;
my $targetout;
my @archs;
GetOptions( 'all', \$aflag, 'out=s', \$targetout, 'arch=s', \@archs )
  or usage();

@archs = split( /,/, join( ",", @archs ) );

# figure out where target directory is (relative to the script source)
my $targdir = $Bin;
$targdir = "$targdir/../targets";
my $currdir = $ENV{PWD};

# build table of predefined profiles
my %profiles;
if ( open( PRF, "<$targdir/definitions/profiles" ) ) {
    while ( my $l = <PRF> ) {
        $l =~ s/\#.*$//;
        $l =~ s/\s*$//;
        if ( $l =~ /^\s*(\w+)\s*:\s*(\w.+)$/ ) {
            $profiles{$1} = [ split( /\s*,\s*/, $2 ) ];
        }
    }
    close(PRF);
}

my @tlist = @ARGV;
if ($aflag) {
    push @tlist, keys(%profiles);
}

if ( $targetout && ( scalar(@tlist) != 1 ) ) {
    usage();
}

# either '+' or '_' can be specified but not both
my $str_tlist = join( '', @tlist );
if ( $str_tlist =~ /_/ && $str_tlist =~ /\+/ ) {
    die("profiles listed cannot contain both '_' and '+'");
}
if ( $str_tlist =~ /_/ && !( -e "$Bin/INTERNAL_BUILD" ) ) {
    print "\nWARNING: cannot use the '_' notation. "
      . "Please use the '+' notation.\n\n";
}
my $plus_notation = ( $str_tlist =~ /\+/ ) ? 1 : 0;

# iterate over targets
while ( my $target = shift @tlist ) {

    # validate
    if ( $target =~ /^([\w_\+]+)$/ ) {
        $target = $1;
    }
    else {
        die("target $target has illegal characters");
    }

    # don't overwrite a non-maketarget target unless forced
    if (   ( !$targetout )
        && ( -d "$targdir/$target" )
        && ( !( -e "$targdir/$target/.maketarget" ) ) )
    {
        print "No need to rebuild $target as it already exists\n";
        next;
    }

    # identify base target and add on suffixes and make sure they exist
    my @blocks = ($plus_notation) ? split( /\+/, $target ) : split( /_/, $target );
    my $base = shift @blocks;
    if ( $profiles{$base} ) {

        # new base and additional blocks
        @blocks = ( @{ $profiles{$base} }, @blocks );
        $base = shift @blocks;
    }

    # make a new target directory
    my $outdir = $targdir;
    $outdir = $currdir . "/targets" if $targetout;

    -d "$outdir/$base" or die("$base is not an existing target");

    push @blocks, @archs;

    foreach my $b (@blocks) {
        $b = "$b.arch" unless $b =~ /\.arch$/;
        die("$targdir/$base/$b not found")
          unless ( -f "$targdir/$base/$b"
            || -f "$targdir/arch/$b"
            || -f "$b" );
    }

    # copy and patch target config
    open( FI, "<$outdir/$base/$base" );
    my $profile;
    {
        local $/;
        $profile = (<FI>);
    }
    close(FI);

    # target name provided
    $target = $targetout if $targetout;

    foreach my $b (@blocks) {
        $b = "$b.arch" unless $b =~ /\.arch$/;
             open( PF, "<$targdir/$base/$b" )
          or open( PF, "<$targdir/arch/$b" )
          or open( PF, "<$b" )
          or die("no $b found");
        while ( my $l = (<PF>) ) { last if ( $l =~ /^\@\@/ ); }
        while ( my $pl = (<PF>) ) {
            if ( $pl =~ /^\-(.*)\s*$/ ) {
                my $s = $1;
                $profile =~ s/$s// or print "$s wasn't in original $base\n";
            }
            elsif ( $pl =~ /^\+(.*)\s*$/ ) {
                my $s = $1;
                $profile .= "\n$s";
            }
        }
        close(PF);
    }

    my $regen;
    if ($plus_notation) {

        # create profile.base only if it does not exist
        if ( !( -e "$outdir/$base/$base.base" ) ) {
            system("mv -f $outdir/$base/$base $outdir/$base/$base.base");
        }
        system("touch $outdir/$base/.maketarget");
        system("rm -f $outdir/$base/$base");
        open( FO, ">$outdir/$base/$base" );
        $regen = $base;
    }
    else {
        system("rm -rf $outdir/$target");
        mkdir("$outdir/$target") or die("mkdir $outdir/$target failed");
        system("touch $outdir/$target/.maketarget");

        open( FO, ">$outdir/$target/$target" );
        $regen = $target;
    }
    print FO "$profile\n\n";
    close(FO);
    
    system("make menuconfig PROFILE=$regen BCM_MENUCONFIG_IS_OLDCONFIG=1 >/dev/null 2>&1");
}

sub usage {
    print q[Usage:

To generate a list of profiles, list their names as arguments

./release/maketargets.pl PROFILE PROFILE_ARCH PROFILE_ARCH_ARCH ....

in this mode, existing profiles from source will not be overwritten
but profiles that are generated by combining a base profile with ARCH files
either by referencing targets/definitions/profiles or by locating the ARCH 
files will be created.

Use the '+' notation in order to generate profile that overwrites the
base profile. The original profile will be saved as 'profile.base'.

./release/maketargets.pl PROFILE PROFILE+ARCH PROFILE+ARCH+ARCH ....

To generate a specific profile even if it means overwriting the original 
profile OR to apply specific ARCH files....

./release/maketargets.pl --out=PROFILE --arch=ARCHNAME --arch=/path/to/ARCHfile.arch [...] PROFILE

NOTE: if --out option is provided then the base profile and target profile will be generated 
               relative to the current directory
      The arch files are always read from the path relative to where maketargets exists
];
    exit 1;
}
