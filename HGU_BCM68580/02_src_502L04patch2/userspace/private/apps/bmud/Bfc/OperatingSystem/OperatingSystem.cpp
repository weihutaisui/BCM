//****************************************************************************
//
//  Copyright (c) 1999  Broadcom Corporation
//  All Rights Reserved
//  No portions of this material may be reproduced in any form without the
//  written permission of:
//          Broadcom Corporation
//          16251 Laguna Canyon Road
//          Irvine, California 92618
//  All information contained in this document is Broadcom Corporation
//  company private, proprietary, and trade secret.
//
//****************************************************************************
//  $Id$
//
//  Filename:       OperatingSystem.cpp
//  Author:         David Pullen
//  Creation Date:  Feb 22, 1999
//
//****************************************************************************
//  Description:
//      This is the abstract base class for the portable Operating System
//      "factory" classes.  The OS factory classes are responsible for creating
//      the correct derived type of OS component class (e.g. for pSOS, it will
//      create a BcmPSOSEvent instance when NewEvent() is called; for Win32, it
//      will create a BcmWin32Event instance).
//
//      Most of the methods in this class will generally only be called by
//      classes derived from the BcmThread base class.
//
//****************************************************************************

//********************** Include Files ***************************************

// My api and definitions...
#include "OperatingSystem.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

//********************** Local Types *****************************************

//********************** Local Constants *************************************

//********************** Local Variables *************************************

// Used when generating names, if the string is NULL or empty.
static unsigned int gUnnamedObjectCounter = 0;

//********************** Class Method Implementations ************************


// Default Constructor.  Initializes the state of the object...
//
// Parameters:  None.
//
// Returns:  N/A
//
BcmOperatingSystem::BcmOperatingSystem(void) :
    fMessageLogSettings("BcmOperatingSystem")
{
    fCurrentThreadState = kNotStarted;
    fCurrentPriority = kNormalPriority;
    pfThread = NULL;
}


// Destructor.  Frees up any memory/objects allocated, cleans up internal
// state.
//
// Parameters:  N/A
//
// Returns:  N/A
//
BcmOperatingSystem::~BcmOperatingSystem()
{
    // Just clear this, I must not delete it.
    pfThread = NULL;
}


// This is a helper method that allows any of the OS Wrapper objects (event,
// timer, etc.) to create its name string for debugging purposes.  The name
// string is either a copy of the string that is passed in, or a unique
// name generated by an incrementing number if the string is empty or NULL.
//
// The returned string has been "newed" from the heap, and is owned by the
// caller, who must delete it when it is no longer needed.
//
// This method will generally be called by the base class constructor for
// BcmEvent, BcmTimer, etc.
//
// Parameters:
//      pName - pointer to the name string to be used.
//      pClassName - name of the class that is calling this method (e.g.
//                   "Event" or "Timer").
//
// Returns:
//      A pointer to the string that was created.
//
char *BcmOperatingSystem::GenerateName(const char *pName, 
                                       const char *pClassName)
{
    char *pObjectName;

    assert(pClassName != NULL);

    // Assign a unique name if one wasn't given.  Otherwise, just copy the one
    // that was given.
    if ((pName == NULL) || (strlen(pName) == 0))
    {
        pObjectName = new char[strlen(pClassName) + 9];

        assert(pObjectName != NULL);

        sprintf(pObjectName, "%s%04d", pClassName, gUnnamedObjectCounter);

        gUnnamedObjectCounter++;
    }
    else
    {
        pObjectName = new char[strlen(pName) + 1];

        assert(pObjectName != NULL);

        strcpy(pObjectName, pName);
    }

    return pObjectName;
}


// This lets the thread update the state information for events that are
// beyond the control of this class (like kInitializing, etc.).
//
// Parameters:
//      newState - the thread's new state.
//
// Returns:  Nothing.
//
void BcmOperatingSystem::SetThreadState(ThreadState newState)
{
    fCurrentThreadState = newState;
}


// Increases the priority of the thread by one level, if possible.
//
// This only works if the thread's current state is kRunning or kSuspended.
//
// Parameters:  None.
//
// Returns:
//      true if successful.
//      false if there was a problem.
//
bool BcmOperatingSystem::IncreasePriority(void)
{
    // Make sure I don't go past the top priority.
    if (fCurrentPriority == kTimeCriticalPriority)
    {
        // Log it...
        gWarningMsg(fMessageLogSettings, "IncreasePriority")
             << "Thread priority already at Time Critical; can't raise it!" << endl;

        return false;
    }

    // Delegate the real work to the derived class.
    return SetPriority((ThreadPriority) (fCurrentPriority + 1));
}

// Decreases the priority of the thread by one level, if possible.
//
// This only works if the thread's current state is kRunning or kSuspended.
//
// Parameters:  None.
//
// Returns:
//      true if successful.
//      false if there was a problem.
//
bool BcmOperatingSystem::DecreasePriority(void)
{
    // Make sure I don't go past the bottom priority.
    if (fCurrentPriority == kIdlePriority)
    {
        // Log the error...
        gWarningMsg(fMessageLogSettings, "DecreasePriority")
             << "Thread priority already at Idle; can't lower it!" << endl;

        return false;
    }

    // Delegate the real work to the derived class.
    return SetPriority((ThreadPriority) (fCurrentPriority - 1));
}


// Added for PR11084.
bool BcmOperatingSystem::SetCpuAffinity(uint32 cpuAffinityMask)
{
    gWarningMsg(fMessageLogSettings, "SetCpuAffinity")
        << "OS doesn't support SMP, or CPU only has one core.  Can't set CPU affinity!" << endl;

    return false;
}


